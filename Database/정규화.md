# 정규화



## 정규화

한 개의 relation에 여러 entity의 attribute들을 혼합 시 정보의 중복이 생긴다. 이는 저장 공간의 낭비를 초래한다. 또한 갱신 이상이 발생할 수 있다.

RDBMS의 중복 최소화를 위해 데이터를 구조화한다. ⇒ 좋은 작은 relation으로 분해하는것이다. 정규화를 거치게 되면, 정규형(특정 조건을 만족하는 relation의 스키마 형태)을 만족하게 된다.



### 갱신 이상

한 relation에서는 변경 했는데, 다른 relation에서는 변경하지 않은 경우.

1. 삽입 이상

    원하지 않는 자료의 삽입이나, 삽입 시 자료가 부족해서 삽입되지 않는 경우.

2. 삭제 이상

    하나의 자료만 삭제하고 싶지만, 그 자료가 포함된 튜플 전체가 삭제될 수 있다.

3. 수정 이상

    정확하지 않거나, 일부의 튜플만 갱신되어 정보가 모호해지거나 일관성이 없어지는 경우이다.
    
    

### Functional Dependency

attribute data들의 의미와 attribute들의 상호 관계로부터 유도되는 제약 조건의 일종이다. X와 Y를 임의의 어트리뷰트 집합이라고 할 때, X의 값이 Y의 값을 유일하게 결정한다면, X는 Y를 함수적으로 결정한다.

![image](https://user-images.githubusercontent.com/46887352/98667678-15086080-2392-11eb-905b-9bb0b36e2085.png)

완전 함수 종속  : 어떤 속성이 기본키에 대해서 완전 종속일 경우.

부분 함수 종속 :  PK가 2개 이상인 합성키인데, 하나의 속성에 종속성을 가지고 있는 경우이다.



### 제 1 정규형

테이블 각각의 값은, 단 하나의 단일 값을 가져야 한다.



### 제 2 정규형

table이 제 1 정규형을 만족하고, PK가 아닌 모든 속성이 PK에 대해서 완전 함수적 종속을 만족하는 정규형이다.

**완전 함수 종속** : X와 Y가 있을 때, X가 Y의 값을 유일하게 결정하는 경우이다.



### 제 3 정규형

table이 제 2 정규형이고, PK가 아닌 모든 속성이 PK에 대해 이행적 함수 종속을 만족하지 않을 경우이다.

B→C에 함수적 종속이다

A→B에 함수종속이다

= A→B이고 B→C이므로 A→C도 만족한다. 이런 경우 제 3 정규형이 아니다.



### BCNF

3NF보다 엄격하다. table에서 모든 결정자가 후보 키(Candidate key)인 정규형이다.



### 장점

DB 변경시 이상 현상을 제거할 수 있다. 새로운 데이터로 인한 추가 확장이 존재할 경우, 구조 변경이 적다.

### 단점

relation 분해로 인해서 relation간의 join 연산이 많아진다. 이는 성능 저하를 유발한다. 정규화를 수행한다는 것은 중복 속성을 최대한 제거하는 것이다. 그래서 한 table의 용량이 작아진다. 그래서 table간의 join이 너무 많은 경우, **반정규화를** 진행한다.

1NF : 테이블 각각의 값은, 단 하나의 단일 값을 가져야 한다.

2NF : PK가 합성키가 아니어야 하고, PK에 완전 함수 종속이어야 한다. (X와 Y가 있을때, X가 Y의 값을 결정짓는 유일한 데이터여야 한다.)

3NF : PK가 아닌 값들 사이에서, 함수 종속이 없어야 한다. 

BCNF : 모든 결정자가 후보키여야 한다. (결정자 : 주어진 rel에 다른 값을 고유하게 결정하는것)

후보키 → 각 table에서 튜플들을 구별하는 데 기준이 되는 하나 혹은 그 이상의 집합