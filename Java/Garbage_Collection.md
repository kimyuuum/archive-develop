# Garbage Collection

[NAVER D2](https://d2.naver.com/helloworld/1329)

## Garbage Collection?

: 메모리 기법 중 하나. 프로그램이 동적으로 할당한 memory 영역 중에서 필요 없게 된 영역을 해제한다.

</br>

### 장점

GC를 지원하는 환경에서는 개발자가 동적으로 할당한 메모리 영역 전체를 완벽하게 관리하지 않아도, 관리를 해준다.

1. 유효하지 않은 Pointer 접근 - **이미 해제된 메모리에 접근**하는 버그.
2. 이중 해제 - 이미 **해제한 메모리를 다시 해제**하는 버그.
3. Memory leak

    **더이상 필요하지 않은 메모리가 해제되지 않고 남아있는 버그**.

    메모리 누수가 반복되면 메모리 고갈로 프로그램이 중단될 수 있다.

    접근 가능 메모리가 증가하여 고갈되는 문제는 GC도 막을수 없다.

⇒ 다음과 같은 버그를 줄이거나, 막을 수 있다.

</br>

### 단점

1. 어떤 메모리를 해제할 지 결정하는데 비용이 든다.
2. 객체가 필요 없어지는 시점을 프로그래머가 미리 알아도, GC 알고리즘이 메모리 해제 시점을 추적한다. ⇒ **오버헤드 발생** 
3. GC가 일어나는 타이밍이나, 점유 시간 예측이 어렵다. ( 할당 해제 시점 예측도 어려움 )
4. 예측 불가능하게 일시 정지가 가능하다.
5. 실시간 시스템에는 적합하지 않다.



</br>



![image](https://user-images.githubusercontent.com/46887352/98662828-ae804400-238b-11eb-895f-d31814d621bc.png)



- 크게 **Heap / Permgen / Thread**로 나눌 수 있다.
- Heap은 Old / Young 영역으로 나뉜다.
- Young 영역은 Eden, Survivor1, Survivor2 로 나뉜다.
- Survivor 영역이 두 개인 이유는, Eden 영역에서 살아남은 객체는 GC되기 전에 Survivor 영역으로 이동을 해야 하고, 그 Survivor 객체가 꽉 차면 해당 Survivor 영역에도 Minor GC가 동작하기 때문에 참조하여 사용되던 객체는 지워지는것을 방지하기 위해 한번 더 옮겨서 관리하다가, 그 영역이 꽉 차면 Old로 옮기기 때문입니다.

</br>

### Young 영역

: 객체가 처음 생성되는 경우 저장되는 영역.

new 연산자를 통해 생성되는 객체 ⇒ Eden Space

### Old 영역

: Young 영역에 존재하던 객체가 오래되어 저장되는 영역.

### Perm 영역

: Class 혹은 method code가 저장되는 영역. JVM에 의해 로딩된다.

</br>

</br>

## GC의 종류

minor GC와 full GC로 나눌 수 있다. 그 중 Minor GC는 Young 영역에 발생하는 GC를 나타낸다.

### Minor GC

Young 영역에서 작동하는 GC.

1. 처음 Minor GC가 발생하기 전, 할당되어있는 모든 객체들은 Eden 영역에만 존재한다.
2. 이때, Minor GC가 발생하면 Eden 영역 중 활성 객체는 Survivor1 영역으로 이동한다.

    ⇒ 이후 Eden 영역에 남아있는 객체들을 Minor GC가 clear시킨다.

3. 다음 Minor GC가 발생하면

    처음 Minor GC 이후 생성된 객체들이 존재하는 Eden 영역의 객체들과, 처음 Minor GC 이후 생존한 객체들이 있는 Survivor1 영역이 가득 차게 되면 그 중에서 살아남은 객체를 Survivor2 영역으로 이동한다. 그럼 Survivor 1 영역은 아무 데이터도 없는 상태가 된다.

4. 위 작업이 Survivor1과 Survivor2를 번갈아가면서 계속 수행한다. 계속해서 활성 객체로 생존하는 객체들은, 시간이 지남에 따라서 Old 영역으로 이동한다.

</br>



### **Full GC**

Old 영역에서 작동하는 GC.

Full GC는, Old 영역이 Full이 되면 수행한다. Old 영역을 스캔하고, 객체들의 참조 상태를 표시한다. 참조되지 않은 객체를 해제하는 작업을 실행한다.

Full GC는 속도가 느리고, 성능에 큰 영향을 끼친다. **Full GC가 수행되는 동안, Java Application은 멈춤 현상**이 발생하기 때문이다.

`포인터 추적 방식`

한 개 이상의 변수가 접근 가능한 메모리는 앞으로 사용할 수 있는 메모리이다. 그러므로 그 밖의 메모리를 해제한다.

`접근 가능한 객체`

어떤 변수가 직접 가리키는 메모리나, 간접적으로 가리키는 메모리를 뜻한다.

</br>

### 여러가지 포인터 추적 기법

### 1. Mark and Sweep (표시하고 쓸기)

: 포인터 추적 기법 중에, 가장 간단한 기법이다. 각 메모리 할당 영역에 표시를 위해 1비트의 메모리를 남긴다.

1. 표시 단계 

    사용 중 - 모든 변수가 가리키는 영역 + 그 영역에서 가리키는 또 다른 영역.

    표시되지 않은 영역은 **접근 불가능한 메모리 영역**을 뜻한다. 

2.  쓸기 단계

    **접근 불가능한 메모리 영역**을 쓸기 단계에서 모두 해제한다.

**단점** 

표시 단계에서 메모리 내용이 변경되지 않아야 한다. 즉, **전체 시스템이 실행 정지**된다. 또한 메모리 전체 영역을 검사해야 한다. 메모리 페이징을 사용하는 경우, 성능 저하가 우려된다.

### 2. 삼색 표시 기법

표시하고 쓸기의 단점을 보완한 기법.

**차이점**

1. 표시 단계에서 2가지가 아닌 3가지 ( 흰, 회, 검 ) 정보 중 하나로 메모리를 표시한다.
2. 프로그램이 **실행 중에도 병행하여 수행**할 수 있다.
3. 메모리 고갈 시 수집을 실행하는 것이 아니라, 주기적으로 수집도 가능하다.

**FLOW**

1. 각각의 객체를 흰색, 회색, 검은색으로 분류한다.

    흰색 : 더이상 접근이 불가능한 객체

    회색 : 접근 가능한 객체이지만, 이 객체에서 **가리키는 객체는 아직 검사하지 않음**.

    검은색 : 접근 가능한 객체이고, 이 영역에서 가리키는 객체는 흰색 객체를 가리키지 않는다.

2. 알고리즘 시작 시, 변수가 가리키는 객체들은 회색으로 표시 된다.

    그 외의 객체 : 흰색

3. 회색으로 표시된 객체 가운데 하나를 선택한다. 그리고 검은색으로 표시한다. 검은색이 가리키는 모든 객체를 회색으로 표시한다.
4. 회색 객체가 하나도 남지 않을 때 까지 위 과정을 반복한다.
5. 흰색은 접근 불가 객체이므로, 모두 해제한다.

### 3. 객체 이동 기법

해제되지 않은 객체를 그대로 두는 것이 아니라, 다른 영역으로 복사한다.

**장점**

1. 해제 후 재사용 가능 영역과, 사용 영역 표시를 위해 추가적인 작업이 필요 없다. 해제 영역을 포인터로 관리하는 방식보다 할당과 해제가 빠르다. 
2. 할당 메모리의 단편화를 예방 가능하다.
3. 연결형 자료구조에서, 서로 연결된 객체들이 메모리 상에서 가까운 위치에 할당될 확률이 높아진다. ⇒ 캐시와 관련해서 성능 향상에 도움이 된다.
4. 객체 이동 기법은 주기적으로 포인터의 내용이 바뀌므로, 포인터 연산 사용이 불가능하다.

### 4. 세대 단위 쓰레기 수집

새롭게 할당된 영역일수록 금방 해제될 확률이 높다.

→ 각 객체를 할당된 시간에 따라 세대별로 구분해서 서로 다른 메모리 영역에 객체를 할당한다.

한 세대의 메모리 영역이 꽉 찬 경우, 살아남은 객체를 오래된 메모리 영역으로 옮긴다.

메모리의 일부 영역만을 주기적으로 수집 가능한 장점이 있다.

Java에서 해당 기법을 사용중이다.

</br>

</br>

## 메모리 관리

프로그램의 요청이 있을 때, 메모리의 일부를 해당 프로그램에 할당한다. 그리고 필요하지 않을 때, 할당을 해제한다.

**가상 메모리 시스템** → Process가 사용한 메모리 주소를 실제 물리 메모리 주소와 구분한다. Process를 구분하고, Disk Swap처리를 이용하여 사용할 수 있는 램의 양을 효과적으로 늘린다. 프로그램 실행 시 필요한 부분만 가상 메모리 시스템에서 주소를 참조하여 물리 메모리에 적재한 뒤 실행한다.

**GC는 프로그램을 위한 컴퓨터 메모리 리소스를 자동으로 할당하고, 해제한다.**

### 메모리 누수

Memory Leak 현상은, 컴퓨터 프로그램이 필요하지 않은 메모리를 계속 점유하는 현상이다. 메모리를 사용하고 반환하지 않는 것이 누적되면 메모리가 낭비된다.

### Generational GC

대부분의 객체는 금방 접근 불가능 상태가 된다. 

오래된 객체 → 새로운 객체의 참조는 드물다. 이 가설의 장점을 살리기 위해 Young / Old 공간이 나뉘어짐.

### Old 영역

512바이트의 덩어리로 되어있는 카드 테이블이 존재한다. 카드 테이블은, Old 영역 객체가 Young 영역 객체를 참조할 때마다 정보가 표시된다.

Young 영역 GC를 실행할 때, Old 영역의 모든 객체 참조를 확인하지 않고, 이 카드 테이블만 확인하면 된다.

Heap을 Old / Young 영역으로 나눈다. Young Generation 영역을 주기적으로 청소한다. 상대적으로 오랜 기간 사용된 객체는 Old Generation으로 보낸다. Old 영역은 공간이 부족할 때만 청소한다.

**장점**

: Young Generation은 Old Generation보다 사이즈가 작고, 힙 공간의 일부이기 때문에 전체 영역 처리보다 시간이 덜 걸린다.

Young Generation 영역은, 한번에 비운다. 그러므로 연속된 여유 공간이 생긴다. ⇒ Compacting

GC가 부분부분을 골라서 객체를 제거했다면, 메모리 파편화가 발생해서 비교적 큰 Data가 들어갈 공간이 부족해진다.



### Young 영역의 GC

Eden 영역의 GC

`bump-the-pointer` 

Eden 영역에 할당된 마지막 객체를 추적한다. 마지막 객체는 Eden의 top에 위치한다. 그 다음 생성되는 객체가 있으면, 해당 객체의 크기가 Eden에 넣기 적당한지 확인한다.

→ 새로운 객체를 생성할 경우, 마지막 top 객체만 점검하면 되므로 매우 빠르게 메모리 할당이 일어난다. 

Multi Thread 환경일 경우, Thread Safe하기 위해서 여러 thread에서 사용하는 객체를 저장하려면 Lock이 발생할 수 밖에 없고, 이는 성능 저하를 유발한다. 이를 개선하기 위해 나온 방법이 TLABs.

`TLABs (Thread Local Allocation Buffers)` 

각각의 쓰레드가 자신의 몫에 해당하는 Eden 영역의 작은 덩어리를 가질 수 있게 한다. 각 Thread는 자신의 Eden 영역에만 접근 가능하므로, Lock 없이 할당 가능하다. 

**Eden 영역에 최초로 객체가 만들어지고, Survivor 영역을 통해서 Old 영역으로 오래 살아남은 객체가 이동한다는 사실은 꼭 기억하기 바란다.**

### Old 영역에 대한 GC

방식에 따라 절차가 달라진다. 기본적으로, 데이터가 가득 차면 GC를 실행한다. 

GC → JDK 7 기준

1. **Serial GC**

    운영 서버에서 절대 사용하면 안된다. Desktop의 CPU 코어가 하나만 있을 때 사용하려고 만든 방식이기 때문에, 성능도 많이 떨어진다. 코어 개수가 적고, 메모리가 작을 때 사용하자.

    Old 영역의 GC는 mark-sweep-compact를 사용한다. 

    1. Mark

        Old 영역에 살아있는 객체를 표시(Mark)한다.

    2. Sweep

        Heap의 앞부분부터 확인하여 살아있는것만 남긴다.

    3. Compact

        각 객체가 연속되게 쌓이도록, 힙의 가장 앞부터 채워서 객체가 존재하는 부분과 없는 부분으로 나눈다. 

2. **Parallel GC**

    Serial GC와 비슷하다. Minor / Full GC 둘 다 all stop 시킨다. 하지만 GC를 처리하는 thread가 여러개이다. 그렇기 때문에 Serial보다는 빠른 성능을 가진다. 메모리가 충분하고, 코어의 개수가 많을 때 유리하다.




![image](https://user-images.githubusercontent.com/46887352/98662995-dcfe1f00-238b-11eb-9652-1a9cf4ea985a.png)



1. **Concurrent Mark & Sweep GC**

    Full GC의 stop-the-world를 줄이기 위해 고안함. 멀티쓰레드로 Minor GC를 실행한다. (Stop-the-world가 발동한다)

    Background에서 thread를 만들어서, Old 영역에 참조되지 않은 객체들은 지속적으로 제거한다. Full GC는 거의 Stop-The-World가 발생하지 않는다.

    Background에서 항상 일을 하고있기 때문에, 다른 GC 방식보다 메모리와 CPU를 더 많이 사용한다. 중간중간 비우기 때문에 Fragmentation이 발생한다. 

    ⇒ CPU 리소스가 부족해진다거나, 메모리 공간이 부족해지면 Serial GC 방식의 청소를 한다.

    

2. **Garbage First GC**

    바둑판 각 영역에 객체를 할당하고, GC를 실행한다. 해당 영역이 꽉 찰 경우, 다른 영역에 객체를 할당하고 GC를 실행한다.

    Heap이 매우 클 경우 효과적이다.

    1. Heap을 Region으로 나눈다. 

        Young/Old로 나누어서 사용한다. Young 영역은 Multi Thread 정리하고, Old 영역은 Background Thread(중간 중간 정리하지 않고, 한 Region을 통째로 정리함) 로 정리한다. 

    2. Region 정리 시, 참조가 없는 객체는 지운다. 사용중인 객체는 다른 Region으로 복사한다. ⇒ 객체 이동 기법을 사용한다.

    다른 Region으로 복사하는 과정에서, 차곡차곡 옮기므로 Compacting이 된다. → No Fragmentation

    CMS 의 문제점인 메모리 Fragmentation을 해결 가능하다.