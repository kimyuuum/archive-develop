## 메모리 관리

### Memory?

cpu가 직접 접근 가능한 내부 기억 장치이다. program이 cpu에서 수행되려면 우선 `memory에 적재`되어야한다.

메모리 관리를 위해 OS는 어디에서 메모리가 적재/ 수행되는지 Address를 통해 관리한다.

memory가 필요한 program에 OS가 memory 할당 / 회수를 진행한다.


</br>
</br>

### 물리 메모리 관리 방식

1. 고정 분할 방식

    물리 메모리를 직접 몇개의 영구 분할로 나눈다.

    내부 단편화가 발생할 우려가 있다.

    물리 메모리보다 큰 프로그램은 실행이 불가능하다.

2. 가변 분할 방식

    매 시점 Program의 크기에 맞게 분할해서 사용한다.

    외부 단편화가 발생한다.

3. 가상 메모리 방식 

    대부분의 컴퓨터에서 쓰이는 방식. 물리메모리보다 큰 프로그램도 수행 가능하다.

    주소가 0부터 시작하는 가상 메모리를 가진다.

    ⇒ OS가 가상 메모리 주소를, 물리 메모리로 매핑한다. 그리고 물리 메모리에 적재시켜 수행한다.

</br>
</br>

### Swap Area

프로그램이 항상 동시에 사용되는것은 아니다. 현재 사용되는 부분만 메모리에 적재하고, 나머지는 보조기억장치에 저장해두었다가 필요하면 적재하여 실행시킨다. 

저장해두는곳 == swap area

</br>

### Page

프로그램을 구성하는 주소 공간을 page라는 작은 기억공간으로 나눠서 관리한다.

외부 단편화를 줄이기 위하여 고안한 방식이다. 

</br>

### Interrupt

주변 장치 및 I/O 장치는 interrupt를 발생시켜 서비스를 요청한다. cpu는 평소 cpu 작업을 스케줄링하여 수행하다가, 인터럽트가 발생하면 cpu작업을 block시키고 interrupt를 수행한다.

- Interrupt vector - 해당 인터럽트가 발생할 경우 처리해야 할 루틴의 주소를 보관하고 있는 table.
- Interrupt Handler - 인터럽트를 처리하기 위한 루틴이다.

</br>

## Process Control Block

OS 커널 내에서는 현재 system 내에서 수행되는 program들을 관리하기 위한 자료구조인 PCB를 두고 있다. Interrupt가 들어올 경우, cpu program을 어디까지 수행했었는지 저장하기 위해 사용한다.

ex) 현재 메모리, 주소, HW상태 등 

Interrupt가 끝나면 저장했던 위치부터 계속 수행한다.

SW Interrupt : Exception, System call 등이 존재한다.

</br>


### 동기식 입출력

: 동기식 I/O를 요청한 프로그램은 입출력이 들어오면 그동안 프로그래밍을 수행하지 못한다.  cpu 낭비가 일어난다. 

⇒ cpu의 효율적인 처리를 위해 다른 Program을 수행하게 한다. 다수의 프로그램을 사용하는 경우, 동기성을 보장하기 위해 장치마다 queue를 두어서 해결한다.

### 비동기식 입출력

I/O 연산 요청 후 결과를 기다리는 것이 아니라, cpu의 제어권을 다시 program에게 부여한다.

</br>

### Direct Memory Access

원칙적으로 메모리는 CPU만 접근 가능하다. 하지만 이 경우 모든 메모리 연산이 cpu를 통해서만 이루어지기 때문에, 비효율적이다. cpu 외에 메모리 접근이 가능한 장치를 하나 더 두자.

로컬 버퍼에서 메모리로 읽어오는 작업을 진행한 후, cpu에게 interrupt를 발생시켜 작업 완료를 알린다.

</br>

### 주 기억 장치 == 메모리

비싸다. 휘발성이다. 빠르다. 용량이 작다.


### 보조 기억 장치

저렴하다. 비휘발성이므로 메모리에서 저장이 필요한 데이터를 보조 기억 장치에 저장한다. 느리다. 용량이 크다.

- File System

    기억해야할 data가 있으면 file 형태로 보조 기억 장치에 저장한다. 디스크를 사용한다

- Swap Area

    memory의 연장 공간. 프로그램 수행 시 수행에 필요한 메모리만 물리 메모리에 올리고, 나머지는 이 swap area에 저장해두었다가 필요하면 꺼내 쓴다. 프로그램이 종료되면 삭제한다.
    
</br>

### 메모리 보안

: 2개의 레지스터 (기준/보안)를 사용해서 체크한다.

- 기준 레지스터 : 프로그램의 시작 주소를 저장한다.
- 보안 레지스터 : 프로그램 주소의 길이를 저장한다.

이 두개를 이용해서 해당 프로그램의 연산이 접근할 때에 범위에 맞게 접근하였는지를 체크한다. 만약 범위 내의 연산이 아니라면 예외처리 Interrupt를 발생시킨다.

</br>

### 가상 메모리

process 전체가 메모리 내에 올라오지 않더라도 실행 가능하게 한다. 물리 메모리 크기에 대해 제약이 자유로워진다. 더 많은 program을 동시에 실행 가능하다. cpu 이용 / 처리율이 높다.

swap에 필요한 I/O가 감소한다.

</br>
</br>
