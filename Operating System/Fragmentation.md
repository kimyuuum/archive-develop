# Fragmentation?



process들이 메모리에 적재 → 제거를 반복하며 생기는 메모리 사이의 사용 불가능한 빈 공간이다.

</br>

### 외부 단편화

메모리 공간 중 사용하지 못하게 되는 일부분. 물리 메모리(RAM)에서 사이사이에 남는 공간들을 모두 합치면 충분한 공간이 될수 있는 크기가 분산되어 있을 때 발생한다. → 압축을 통하여 일정 해결 가능하지만 오버헤드가 크다.

### 내부 단편화

프로세스가 사용하는 메모리 공간에 포함된 남는 부분이다. 메모리 분할 자유 공간이 10,000B 있고 process A가 9990B를 사용하면, 10B는 내부 단편화가 발생한다.



### </br>

### Paging

하나의 process가 사용하는 메모리 공간이 무조건 연속적이어야 한다는 제약을 해결한다. 외부 단편화를 해결하기 위해서 고안됐다. 가상 메모리가 물리 메모리에 적재될 때 연속되어 저장 될 필요가 없고, 물리 메모리의 남는 frame에 적절하게 배치된다. 하지만 내부 단편화 발생 우려가 있다.

ex) 페이지 크기가 1024B이고 process A가 3172B 메모리를 요구하면, 1024 * 4개가 필요하다. 결국 4번째 Page에서 내부 단편화가 발생한다.

### Segmentation

논리/물리 메모리를 같은 크기의 블록이 아닌 서로 다른 크기의 논리적 단위인 segment로 분할한다. segment table에는 각 segment의 시작 물리주소와, 길이를 저장한다. → 외부 단편화의 우려가 있다.

</br>

</br>

## Page 교체

가상 메모리를 사용하면 page fault 발생 시 원하는 page를 보조 장치에서 가져온다. 하지만 물리 메모리가 모두 사용중인 경우, 페이지 교체가 이뤄져야한다.

1. 디스크에서 필요한 page의 위치를 찾는다.
2. 빈 page frame을 찾는다.
   1. 페이지 교체 알고리즘을 통해 희생될 page를 고른다.
   2. 희생될 page를 디스크에 기록하고, 관련 page table을 수정한다.

### FIFO ( First In First Out )

- 물리 메모리에 들어온 페이지 순서대로 페이지 교체 시점에 먼저 나간다.

### Optimal Page Replacement

- 앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체한다. 가장 일리가 있지만 오버헤드가 크다.

### LRU 페이지 교체 (Least Recently Used)

- 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체한다. (가장 최적)

### LFU (Least Frequently Used)

- 제일 적게 사용된 페이지를 교체시킨다.

### Cache

- 프로세서 가까이에 위치하면서 빈번하게 사용되는 data를 놔두는 장소. 캐시에 목적 data가 저장되어 있다면 바로 접근 → 출력 가능해야 한다.



</br>

